{"meta":{"title":"silvercat","subtitle":"silvercat","description":"本网站是个人兴趣爱好，总结分享经验，记录生活点滴的平台，希望在以后的学习旅途中，走出自己的风景。","author":"silvercat","url":"https://silvercatcloud.github.io","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2024-02-18T13:26:03.272Z","comments":true,"path":"404.html","permalink":"https://silvercatcloud.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2024-02-18T13:23:15.000Z","updated":"2024-02-18T13:23:54.953Z","comments":true,"path":"categories/index.html","permalink":"https://silvercatcloud.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-02-18T13:24:05.000Z","updated":"2024-02-18T13:24:14.763Z","comments":true,"path":"tags/index.html","permalink":"https://silvercatcloud.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2024-02-18T13:24:28.000Z","updated":"2024-02-18T13:24:41.290Z","comments":true,"path":"about/index.html","permalink":"https://silvercatcloud.github.io/about/index.html","excerpt":"","text":""},{"title":"comtact","date":"2024-02-18T14:20:54.000Z","updated":"2024-02-18T14:25:03.041Z","comments":true,"path":"contact/index.html","permalink":"https://silvercatcloud.github.io/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"Mybatis基础","slug":"Mybatis基础","date":"2024-02-17T13:27:14.000Z","updated":"2024-02-19T12:04:20.433Z","comments":true,"path":"2024/02/17/mybatis-ji-chu/","link":"","permalink":"https://silvercatcloud.github.io/2024/02/17/mybatis-ji-chu/","excerpt":"","text":"Mybatis我们做为后端程序开发人员，通常会使用Java程序来完成对数据库的操作。Java程序操作数据库，现在主流的方式是：Mybatis。 MyBatis是一款优秀的持久层框架，用于简化JDBC的开发 入门程序实现创建springboot工程创建springboot工程，并导入 mybatis的起步依赖、mysql的驱动包。 项目工程创建完成后，自动在pom.xml文件中，导入Mybatis依赖和MySQL驱动依赖 12345678910111213141516171819202122 &lt;!-- 仅供参考：只粘贴了pom.xml中部分内容 --&gt;&lt;dependencies&gt; &lt;!-- mybatis起步依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动包依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring单元测试 (集成了junit) --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 数据准备 创建用户表user，并创建对应的实体类User。 用户表： 12345678910111213141516-- 用户表create table user( id int unsigned primary key auto_increment comment &#x27;ID&#x27;, name varchar(100) comment &#x27;姓名&#x27;, age tinyint unsigned comment &#x27;年龄&#x27;, gender tinyint unsigned comment &#x27;性别, 1:男, 2:女&#x27;, phone varchar(11) comment &#x27;手机号&#x27;) comment &#x27;用户表&#x27;;-- 测试数据insert into user(id, name, age, gender, phone) VALUES (null,&#x27;白眉鹰王&#x27;,55,&#x27;1&#x27;,&#x27;18800000000&#x27;);insert into user(id, name, age, gender, phone) VALUES (null,&#x27;金毛狮王&#x27;,45,&#x27;1&#x27;,&#x27;18800000001&#x27;);insert into user(id, name, age, gender, phone) VALUES (null,&#x27;青翼蝠王&#x27;,38,&#x27;1&#x27;,&#x27;18800000002&#x27;);insert into user(id, name, age, gender, phone) VALUES (null,&#x27;紫衫龙王&#x27;,42,&#x27;2&#x27;,&#x27;18800000003&#x27;);insert into user(id, name, age, gender, phone) VALUES (null,&#x27;光明左使&#x27;,37,&#x27;1&#x27;,&#x27;18800000004&#x27;);insert into user(id, name, age, gender, phone) VALUES (null,&#x27;光明右使&#x27;,48,&#x27;1&#x27;,&#x27;18800000005&#x27;); 实体类 实体类的属性名与表中的字段名一一对应。 12345678public class User &#123; private Integer id; //id（主键） private String name; //姓名 private Short age; //年龄 private Short gender; //性别 private String phone; //手机号//省略GET, SET方法&#125; 配置Mybatis​ 在之前使用图形化客户端工具，连接MySQL数据库时，需要配置： 连接数据库的四大参数： MySQL驱动类 登录名 密码 数据库连接字符串 application.properties: 12345678#驱动类名称spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver#数据库连接的urlspring.datasource.url=jdbc:mysql://localhost:3306/mybatis#连接数据库的用户名spring.datasource.username=root#连接数据库的密码spring.datasource.password=1234 上述的配置，可以直接复制过去，不要敲错了。 全部都是 spring.datasource.xxxx 开头。 编写SQL语句在创建出来的springboot工程中，在引导类所在包下，在创建一个包 mapper。在mapper包下创建一个接口 UserMapper ，这是一个持久层接口（Mybatis的持久层接口规范一般都叫 XxxMapper）。 UserMapper： 1234567891011package com.silvercat.mapper;import com.silvercat.pojo.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;@Mapperpublic interface UserMapper &#123; // 查询所有用户数据 @Select(&quot;select * from user&quot;) List&lt;User&gt; list();&#125; @Mapper注解：表示是mybatis中的Mapper接口 程序运行时：框架会自动生成接口的实现类对象(代理对象)，并给交Spring的IOC容器管理 @Select注解：代表的就是select查询，用于书写select查询语句 单元测试​ 在创建出来的SpringBoot工程中，在src下的test目录下，已经自动帮我们创建好了测试类 ，并且在测试类上已经添加了注解 @SpringBootTest，代表该测试类已经与SpringBoot整合。 该测试类在运行时，会自动通过引导类加载Spring的环境（IOC容器）。我们要测试那个bean对象，就可以直接通过@Autowired注解直接将其注入进行，然后就可以测试了。 123456789101112@SpringBootTestclass SpringbootMybatisQuickstartApplicationTests &#123; @Autowired private UserMapper userMapper; @Test public void testListUser ()&#123; List&lt;User&gt; userList = userMapper.list(); userList.stream().forEach(user -&gt; &#123; System.out.println(user); &#125;); &#125;&#125; 运行结果： 123456User&#123;id=1, name=&#x27;白眉鹰王&#x27;, age=55, gender=1, phone=&#x27;18800000000&#x27;&#125;User&#123;id=2, name=&#x27;金毛狮王&#x27;, age=45, gender=1, phone=&#x27;18800000001&#x27;&#125;User&#123;id=3, name=&#x27;青翼蝠王&#x27;, age=38, gender=1, phone=&#x27;18800000002&#x27;&#125;User&#123;id=4, name=&#x27;紫衫龙王&#x27;, age=42, gender=2, phone=&#x27;18800000003&#x27;&#125;User&#123;id=5, name=&#x27;光明左使&#x27;, age=37, gender=1, phone=&#x27;18800000004&#x27;&#125;User&#123;id=6, name=&#x27;光明右使&#x27;, age=48, gender=1, phone=&#x27;18800000005&#x27;&#125; 解决SQL警告与提示默认我们在UserMapper接口上加的@Select注解中编写SQL语句是没有提示的。 如果想让idea给我们提示对应的SQL语句，我们需要在IDEA中配置与MySQL数据库的链接。 默认我们在UserMapper接口上的@Select注解中编写SQL语句是没有提示的。如果想让idea给出提示，可以做如下配置： 配置完成之后，发现SQL语句中的关键字有提示了，但还存在不识别表名(列名)的情况： JDBC介绍(了解)JDBC： ( Java DataBase Connectivity )，就是使用Java语言操作关系型数据库的一套API。 本质： sun公司官方定义的一套操作所有关系型数据库的规范，即接口。 各个数据库厂商去实现这套接口，提供数据库驱动jar包。 我们可以使用这套接口(JDBC)编程，真正执行的代码是驱动jar包中的实现类。 代码原始的JDBC程序操作数据库的步骤如下： 注册驱动 获取连接对象 执行SQL语句，返回执行结果 处理执行结果 释放资源 在pom.xml文件中已引入MySQL驱动依赖，我们直接编写JDBC代码即可 JDBC具体代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import com.itheima.pojo.User;import org.junit.jupiter.api.Test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;import java.util.ArrayList;import java.util.List;public class JdbcTest &#123; @Test public void testJdbc() throws Exception &#123; //1. 注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2. 获取数据库连接 String url=&quot;jdbc:mysql://127.0.0.1:3306/mybatis&quot;; String username = &quot;root&quot;; String password = &quot;xxx&quot;; Connection connection = DriverManager.getConnection(url, username, password); //3. 执行SQL Statement statement = connection.createStatement(); //操作SQL的对象 String sql=&quot;select id,name,age,gender,phone from user&quot;; ResultSet rs = statement.executeQuery(sql);//SQL查询结果会封装在ResultSet对象中 List&lt;User&gt; userList = new ArrayList&lt;&gt;();//集合对象（用于存储User对象） //4. 处理SQL执行结果 while (rs.next())&#123; //取出一行记录中id、name、age、gender、phone下的数据 int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); short age = rs.getShort(&quot;age&quot;); short gender = rs.getShort(&quot;gender&quot;); String phone = rs.getString(&quot;phone&quot;); //把一行记录中的数据，封装到User对象中 User user = new User(id,name,age,gender,phone); userList.add(user);//User对象添加到集合 &#125; //5. 释放资源 statement.close(); connection.close(); rs.close(); //遍历集合 for (User user : userList) &#123; System.out.println(user); &#125; &#125;&#125; 但是传统的JDBC程序耦合性太高。查询结果的解析及封装非常繁琐。每次查询数据库都要获得连接，操作完释放连接，资源浪费，性能降低。 技术对比分析了JDBC的缺点之后，我们再来看一下在mybatis中，是如何解决这些问题的： 数据库连接四要素(驱动、链接、用户名、密码)，都配置在springboot默认的配置文件 application.properties中 查询结果的解析及封装，由mybatis自动完成映射封装，我们无需关注 在mybatis中使用了数据库连接池技术，从而避免了频繁的创建连接、销毁连接而带来的资源浪费。 使用SpringBoot+Mybatis的方式操作数据库，能够提升开发效率、降低资源浪费 而对于Mybatis来说，我们在开发持久层程序操作数据库时，需要重点关注以下两个方面： application.properties 12345678#驱动类名称spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver#数据库连接的urlspring.datasource.url=jdbc:mysql://localhost:3306/mybatis#连接数据库的用户名spring.datasource.username=root#连接数据库的密码spring.datasource.password=1234 Mapper接口（编写SQL语句） 12345@Mapperpublic interface UserMapper &#123; @Select(&quot;select id, name, age, gender, phone from user&quot;) public List&lt;User&gt; list();&#125; 数据库连接池 在前面我们所讲解的mybatis中，使用了数据库连接池技术，避免频繁的创建连接、销毁连接而带来的资源浪费。 没有使用数据库连接池： 客户端执行SQL语句：要先创建一个新的连接对象，然后执行SQL语句，SQL语句执行后又需要关闭连接对象从而释放资源，每次执行SQL时都需要创建连接、销毁链接，这种频繁的重复创建销毁的过程是比较耗费计算机的性能。 数据库连接池是个容器，负责分配、管理数据库连接(Connection) 程序在启动时，会在数据库连接池(容器)中，创建一定数量的Connection对象 ​ 允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 客户端在执行SQL时，先从连接池中获取一个Connection对象，然后在执行SQL语句，SQL语句执行完之后，释放Connection时就会把Connection对象归还给连接池（Connection对象可以复用） 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏 客户端获取到Connection对象了，但是Connection对象并没有去访问数据库(处于空闲)，数据库连接池发现Connection对象的空闲时间 &gt; 连接池中预设的最大空闲时间，此时数据库连接池就会自动释放掉这个连接对象 数据库连接池的好处： 资源重用 提升系统响应速度 避免数据库连接遗漏 实现数据库连接池官方(sun)提供了数据库连接池标准（javax.sql.DataSource接口） 常见的数据库连接池： C3P0 DBCP Druid Hikari (springboot默认) 现在使用更多的是：Hikari、Druid （性能更优越） 在pom.xml文件中引入依赖 123456&lt;dependency&gt; &lt;!-- Druid连接池依赖 --&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt; 在application.properties中引入数据库连接配置 1234spring.datasource.druid.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.druid.url=jdbc:mysql://localhost:3306/mybatisspring.datasource.druid.username=rootspring.datasource.druid.password=1234 lombok介绍Lombok是一个实用的Java类库，可以通过简单的注解来简化和消除一些必须有但显得很臃肿的Java代码。 通过注解的形式自动生成构造器、getter&#x2F;setter、equals、hashcode、toString等方法，并可以自动化生成日志变量，简化java开发、提高效率。 注解 作用 @Getter&#x2F;@Setter 为所有的属性提供get&#x2F;set方法 @ToString 会给类自动生成易阅读的 toString 方法 @EqualsAndHashCode 根据类所拥有的非静态字段自动重写 equals 方法和 hashCode 方法 @Data 提供了更综合的生成代码功能（@Getter + @Setter + @ToString + @EqualsAndHashCode） @NoArgsConstructor 为实体类生成无参的构造器方法 @AllArgsConstructor 为实体类生成除了static修饰的字段之外带有各参数的构造器方法。 使用第1步：在pom.xml文件中引入依赖 12345&lt;!-- 在springboot的父工程中，已经集成了lombok并指定了版本号，故当前引入依赖时不需要指定version --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 第2步：在实体类上添加注解 123456789101112import lombok.Data;@Data //getter方法、setter方法、toString方法、hashCode方法、equals方法@NoArgsConstructor //无参构造@AllArgsConstructor//全参构造public class User &#123; private Integer id; private String name; private Short age; private Short gender; private String phone;&#125; 说明：@Data注解中不包含全参构造方法，通常在实体类上，还会添加上：全参构造、无参构造 Mybatis基础操作日志输入 在Mybatis当中我们可以借助日志，查看到sql语句的执行、执行传递的参数以及执行结果。具体操作如下： 打开application.properties文件 开启mybatis的日志，并指定输出到控制台 12#指定mybatis输出日志的位置, 输出控制台mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 开启日志之后，我们再次运行单元测试，可以看到在控制台中，输出了以下的SQL语句信息： 但是我们发现输出的SQL语句：delete from emp where id &#x3D; ?，我们输入的参数16并没有在后面拼接，id的值是使用?进行占位。那这种SQL语句我们称为预编译SQL。 预编译SQL介绍预编译SQL有两个优势： 性能更高 更安全(防止SQL注入) 性能更高：预编译SQL，编译一次之后会将编译后的SQL语句缓存起来，后面再次执行这条语句时，不会再次编译。（只是输入的参数不同） 更安全(防止SQL注入)：将敏感字进行转义，保障SQL的安全性。 SQL注入SQL注入：是通过操作输入的数据来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。 由于没有对用户输入进行充分检查，而SQL又是拼接而成，在用户输入参数时，在参数中添加一些SQL关键字，达到改变SQL运行结果的目的，也可以完成恶意攻击。 无sql注入 有sql注入 参数占位符在Mybatis中提供的参数占位符有两种：${…} 、#{…} #{…} 执行SQL时，会将#{…}替换为?，生成预编译SQL，会自动设置参数值 使用时机：参数传递，都使用#{…} ${…} 拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题 使用时机：如果对表名、列表进行动态设置时使用 注意事项：在项目开发中，建议使用#{…}，生成预编译SQL，防止SQL注入安全。 新增1234567@Mapperpublic interface EmpMapper &#123; @Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#&#123;username&#125;, #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entrydate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;) public void insert(Emp emp);&#125; 说明：#{…} 里面写的名称是对象的属性名 测试类： 12345678910111213141516171819202122232425262728293031import com.itheima.mapper.EmpMapper;import com.itheima.pojo.Emp;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.time.LocalDate;import java.time.LocalDateTime;@SpringBootTestclass SpringbootMybatisCrudApplicationTests &#123; @Autowired private EmpMapper empMapper; @Test public void testInsert()&#123; //创建员工对象 Emp emp = new Emp(); emp.setUsername(&quot;tom&quot;); emp.setName(&quot;汤姆&quot;); emp.setImage(&quot;1.jpg&quot;); emp.setGender((short)1); emp.setJob((short)1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); emp.setDeptId(1); //调用添加方法 empMapper.insert(emp); &#125;&#125; 主键返回主键返回代码实现： 123456789@Mapperpublic interface EmpMapper &#123; //会自动将生成的主键值，赋值给emp对象的id属性 @Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;) @Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#&#123;username&#125;, #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entrydate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;) public void insert(Emp emp);&#125; 测试： 123456789101112131415161718192021222324@SpringBootTestclass SpringbootMybatisCrudApplicationTests &#123; @Autowired private EmpMapper empMapper; @Test public void testInsert()&#123; //创建员工对象 Emp emp = new Emp(); emp.setUsername(&quot;jack&quot;); emp.setName(&quot;杰克&quot;); emp.setImage(&quot;1.jpg&quot;); emp.setGender((short)1); emp.setJob((short)1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); emp.setDeptId(1); //调用添加方法 empMapper.insert(emp); System.out.println(emp.getDeptId()); &#125;&#125; 更新，查询… 操作本质和增加都差不多 1234567891011121314@Mapperpublic interface EmpMapper &#123; @Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)//使用#&#123;key&#125;方式获取方法中的参数值 public void delete(Integer id); //会自动将生成的主键值，赋值给emp对象的id属性 @Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;) @Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#&#123;username&#125;, #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entrydate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;) public void insert(Emp emp); @Update(&quot;update emp set username=#&#123;username&#125;, name=#&#123;name&#125;, gender=#&#123;gender&#125;, image=#&#123;image&#125;, job=#&#123;job&#125;, entrydate=#&#123;entrydate&#125;, dept_id=#&#123;deptId&#125;, update_time=#&#123;updateTime&#125; where id=#&#123;id&#125;&quot;) public void update(Emp emp); @Select(&quot;select * from emp where id=#&#123;id&#125;&quot;) public Emp getById(Integer id);&#125; 12345678910111213141516171819202122232425262728293031323334353637@SpringBootTestclass SpringbootMybatisCrudApplicationTests &#123; @Autowired //从Spring的IOC容器中，获取类型是EmpMapper的对象并注入 private EmpMapper empMapper;// @Test// public void testDel()&#123;// //调用删除方法// empMapper.delete(16);// &#125;//@Test//public void testUpdate()&#123;// //创建员工对象// Emp emp = new Emp();// emp.setId(8);// emp.setUsername(&quot;songdaxia&quot;);// emp.setPassword(null);// emp.setName(&quot;橙子&quot;);// emp.setImage(&quot;2.jpg&quot;);// emp.setGender((short)2);// emp.setJob((short)2);// emp.setEntrydate(LocalDate.of(1995,5,20));// emp.setCreateTime(null);// emp.setUpdateTime(LocalDateTime.now());// emp.setDeptId(2);// //调用添加方法// empMapper.update(emp);// //返回ID值//&#125; @Test public void testGetById()&#123; Emp emp = empMapper.getById(1); System.out.println(emp); &#125;&#125; 数据封装我们看到查询返回的结果中大部分字段是有值的，但是deptId，createTime，updateTime这几个字段是没有值的，而数据库中是有对应的字段值的，这是为什么呢？ 原因如下： 实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。 如果实体类属性名和数据库表查询返回的字段名不一致，不能自动封装。 解决方案： 起别名 结果映射 开启驼峰命名 起别名：在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样 12345@Select(&quot;select id, username, password, name, gender, image, job, entrydate, &quot; + &quot;dept_id AS deptId, create_time AS createTime, update_time AS updateTime &quot; + &quot;from emp &quot; + &quot;where id=#&#123;id&#125;&quot;)public Emp getById(Integer id); 再次执行测试类： 手动结果映射：通过 @Results及@Result 进行手动结果映射（繁琐） 12345@Results(&#123;@Result(column = &quot;dept_id&quot;, property = &quot;deptId&quot;), @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;), @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;)&#125;)@Select(&quot;select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where id=#&#123;id&#125;&quot;)public Emp getById(Integer id); @Results源代码： 12345678@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface Results &#123;String id() default &quot;&quot;;Result[] value() default &#123;&#125;; //Result类型的数组&#125; @Result源代码： 123456789101112131415161718192021@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)@Repeatable(Results.class)public @interface Result &#123;boolean id() default false;//表示当前列是否为主键（true:是主键）String column() default &quot;&quot;;//指定表中字段名String property() default &quot;&quot;;//指定类中属性名Class&lt;?&gt; javaType() default void.class;JdbcType jdbcType() default JdbcType.UNDEFINED;Class&lt;? extends TypeHandler&gt; typeHandler() default UnknownTypeHandler.class;One one() default @One;Many many() default @Many;&#125; **开启驼峰命名(推荐)**：如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射 驼峰命名规则： abc_xyz &#x3D;&gt; abcXyz 表中字段名：abc_xyz 类中属性名：abcXyz 12# 在application.properties中添加：mybatis.configuration.map-underscore-to-camel-case=true 要使用驼峰命名前提是 实体类的属性 与 数据库表中的字段名严格遵守驼峰命名。 条件查询 （解决SQL注入风险） 使用MySQL提供的字符串拼接函数：concat(‘%’ , ‘关键字’ , ‘%’) 123456789101112@Mapperpublic interface EmpMapper &#123; @Select(&quot;select * from emp &quot; + &quot;where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) &quot; + &quot;and gender = #&#123;gender&#125; &quot; + &quot;and entrydate between #&#123;begin&#125; and #&#123;end&#125; &quot; + &quot;order by update_time desc&quot;) public List&lt;Emp&gt; list(String name, Short gender, LocalDate begin, LocalDate end);&#125; Mybatis的XML配置文件Mybatis的开发有两种方式： 注解 XML XML映射优点 XML映射文件在MyBatis框架中具有以下几个主要优点： 1.解耦：通过将SQL语句与Java代码分离，实现了业务逻辑和数据库操作的解耦。这样可以独立维护数据库查询逻辑，方便团队中的不同角色（如Java开发者、DBA等）分工合作。 ​ 2.可读性：XML文件以结构化方式清晰地表示SQL查询和其他数据库操作，使得SQL语句更易于阅读和理解，不需要在Java代码中嵌入大量的字符串。 ​ 3.动态SQL支持：MyBatis的XML映射提供了强大的动态SQL功能，能够根据条件动态生成SQL语句，比如、、、、等标签，这些在纯Java代码中实现起来会非常复杂。。。。 配置文件规范 编写XML映射文件 xml映射文件中的dtd约束，直接从mybatis官网复制即可 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;&quot;&gt; &lt;/mapper&gt; 配置：XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.mapper.EmpMapper&quot;&gt; &lt;!--查询操作--&gt; &lt;select id=&quot;list&quot; resultType=&quot;com.itheima.pojo.Emp&quot;&gt; select * from emp where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender = #&#123;gender&#125; and entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc &lt;/select&gt;&lt;/mapper&gt; MybatisXMybatisX是一款基于IDEA的快速开发Mybatis的插件，为效率而生。 Mybatis动态SQL动态SQL-if+动态SQL-sql&amp;include条件查询12345678910111213141516171819&lt;sql id=&quot;commonSelect&quot;&gt; select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp &lt;/sql&gt; &lt;!--查询操作--&gt; &lt;select id=&quot;list&quot; resultType=&quot;com.silvercat.pojo.Emp&quot;&gt; &lt;include refid=&quot;commonSelect&quot;/&gt; &lt;where&gt;&lt;!--!!!!!!!!!!!!!!!!!!!!--&gt; &lt;if test=&quot;name != null&quot;&gt; name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt; and gender = #&#123;gender&#125; &lt;/if&gt; &lt;if test=&quot;begin != null and end != null&quot;&gt; and entrydate between #&#123;begin&#125; and #&#123;end&#125; &lt;/if&gt; &lt;/where&gt; order by update_time desc &lt;/select&gt; 12345678@Testpublic void testList()&#123; //姓名为null List&lt;Emp&gt; list = empMapper.list(null, (short)1, null, null); for(Emp emp : list)&#123; System.out.println(emp); &#125;&#125; 随便给几个条件，都可以有与之对应的查询结果，这就是Mybatis的动态SQL。 更新员工修改Mapper接口： 123456@Mapperpublic interface EmpMapper &#123; //删除@Update注解编写的SQL语句 //update操作的SQL语句编写在Mapper映射文件中 public void update(Emp emp);&#125; 修改Mapper映射文件： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.mapper.EmpMapper&quot;&gt; &lt;!--更新操作--&gt; &lt;update id=&quot;update&quot;&gt; update emp &lt;!-- 使用set标签，代替update语句中的set关键字 --&gt; &lt;set&gt;&lt;!--!!!!!!!!!!!!!!!!!!!!--&gt; &lt;if test=&quot;username != null&quot;&gt; username=#&#123;username&#125;, &lt;/if&gt; &lt;if test=&quot;name != null&quot;&gt; name=#&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt; gender=#&#123;gender&#125;, &lt;/if&gt; &lt;if test=&quot;image != null&quot;&gt; image=#&#123;image&#125;, &lt;/if&gt; &lt;if test=&quot;job != null&quot;&gt; job=#&#123;job&#125;, &lt;/if&gt; &lt;if test=&quot;entrydate != null&quot;&gt; entrydate=#&#123;entrydate&#125;, &lt;/if&gt; &lt;if test=&quot;deptId != null&quot;&gt; dept_id=#&#123;deptId&#125;, &lt;/if&gt; &lt;if test=&quot;updateTime != null&quot;&gt; update_time=#&#123;updateTime&#125; &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 测试方法： 12345678910111213@Testpublic void testUpdate2()&#123; //要修改的员工信息 Emp emp = new Emp(); emp.setId(20); emp.setUsername(&quot;Tom111&quot;); emp.setName(&quot;汤姆111&quot;); emp.setUpdateTime(LocalDateTime.now()); //调用方法，修改员工数据 empMapper.update(emp);&#125; 小结 &lt;if&gt; 用于判断条件是否成立，如果条件为true，则拼接SQL 形式： 1&lt;if test=&quot;name != null&quot;&gt; … &lt;/if&gt; &lt;where&gt; where元素只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR &lt;set&gt; 动态地在行首插入 SET 关键字，并会删掉额外的逗号。（用在update语句中） 动态SQL-foreach SQL语句： 1delete from emp where id in (1,2,3); Mapper接口： 12345@Mapperpublic interface EmpMapper &#123; //批量删除 public void deleteByIds(List&lt;Integer&gt; ids);&#125; XML映射文件： 使用&lt;foreach&gt;遍历deleteByIds方法中传递的参数ids集合 123&lt;foreach collection=&quot;集合名称&quot; item=&quot;集合遍历出来的元素/项&quot; separator=&quot;每一次遍历使用的分隔符&quot; open=&quot;遍历开始前拼接的片段&quot; close=&quot;遍历结束后拼接的片段&quot;&gt;&lt;/foreach&gt; 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.mapper.EmpMapper&quot;&gt; &lt;!--删除操作--&gt; &lt;delete id=&quot;deleteByIds&quot;&gt; delete from emp where id in &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/delete&gt;&lt;/mapper&gt; 动态SQL-sql&amp;include我们可以对重复的代码片段进行抽取，将其通过&lt;sql&gt;标签封装到一个SQL片段，然后再通过&lt;include&gt;标签进行引用。 &lt;sql&gt;：定义可重用的SQL片段 &lt;include&gt;：通过属性refid，指定包含的SQL片段 SQL片段： 抽取重复的代码 123&lt;sql id=&quot;commonSelect&quot;&gt; select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp&lt;/sql&gt; 然后通过&lt;include&gt; 标签在原来抽取的地方进行引用。操作如下： 123456789101112131415&lt;select id=&quot;list&quot; resultType=&quot;com.itheima.pojo.Emp&quot;&gt; &lt;include refid=&quot;commonSelect&quot;/&gt; &lt;where&gt; &lt;if test=&quot;name != null&quot;&gt; name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt; and gender = #&#123;gender&#125; &lt;/if&gt; &lt;if test=&quot;begin != null and end != null&quot;&gt; and entrydate between #&#123;begin&#125; and #&#123;end&#125; &lt;/if&gt; &lt;/where&gt; order by update_time desc&lt;/select&gt;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://silvercatcloud.github.io/tags/java/"}]},{"title":"GIT拉取GitHub项目到本地","slug":"GIT拉取GitHub项目到本地","date":"2024-02-10T07:23:25.000Z","updated":"2024-02-19T12:03:39.556Z","comments":true,"path":"2024/02/10/git-la-qu-github-xiang-mu-dao-ben-di/","link":"","permalink":"https://silvercatcloud.github.io/2024/02/10/git-la-qu-github-xiang-mu-dao-ben-di/","excerpt":"","text":"关键语句： 123456git init //把这个目录变成Git可以管理的仓库git add README.md //文件添加到仓库git add . //不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了 git commit -m &quot;first commit&quot; //把文件提交到仓库git remote add origin git@github.com:wangjiax9/practice.git //关联远程仓库git push -u origin master //把本地库的所有内容推送到远程库上 详见：https://zhuanlan.zhihu.com/p/193140870","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://silvercatcloud.github.io/tags/Git/"}]}],"categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://silvercatcloud.github.io/tags/java/"},{"name":"Git","slug":"Git","permalink":"https://silvercatcloud.github.io/tags/Git/"}]}